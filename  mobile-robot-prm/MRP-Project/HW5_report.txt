Simulation Localization
------------------------------------------------------------------------

The algorithm implemented to solve the 8 robot localization problem for
this assignment employs simple scripting and conditional checks. First, 
we assume that we can only use the front sonar array. Second, we assume
that all other robots are moved out of the way of the robot listening on
the port specified when the Java program is run. This second assumption
is really only important when localizing the magenta and cyan robots in
the hallway. For example, the blue robot should be moved when localizing
the magenta robot and vice-versa. Although we make this assumption, this
program still succeeds whether other robots are not moved.

The red, green, cyan, yellow, grey, and white robots on ports 6665, 
6666, 6667, 6669, 6670, and 6672, respectively, all have unique 
initial frontal sonar array readings (if all 8 sonar are considered)
and do not require any motion to localize. All the program does is 
compare the initial sonar reading to hard-coded arrays representing each
of these 6 robots' expected initial sonar readings to determine which
robot is which. Once that is known we print out that robot's initial
location, which is also hard-coded into the program.

The magenta and blue robots, on ports 6668 and 6671, respectively, are
a little more difficult to localize because they have the same initial
front sonar array readings. Once we determine that the robot is not one
of the other 6 robots with unique front sonar array readings, we
instruct it to rotate 180 degrees to face south and then to start moving
forward until it either detects something within 2.3m with its fifth 
front sonar from its left or travels a distance of 4.5m. If it travels 
4.5m without detecting something then it is the magenta robot and the
blue robot must have been moved out of its way. If it detects something 
then it checks its seventh sonar from the left. If the range reading is 
less than 2.0m then we know the robot is still in the hallway. Thus, it 
must be the magenta robot detecting the blue robot ahead of it. If the 
range reading is more than 2.0m then we know the robot is in the 
intersection of two hallways and must be the blue robot.


Real Robot Localization
------------------------------------------------------------------------

This algorithm is very susceptible to sonar errors since it initially
checks each front sonar array reading against hard-coded values. This
algorithm can be modified to account for sonar error by incorporating an
absolute error metric that will decide if two sonar array readings are
similar if their difference is below some predetermined threshold. Also,
the sonar array readings recorded by the real robot can be averaged over
time to try and reduce noise. Unless these changes are made, this 
algorithm is very unlikely to be successful when deployed on a real 
robot.

An algorithm deployed on a real robot can be developed as follows:

- The white robot can be identified immediately because its close
proximity to the wall on its right. 

- The red and green robots can be identified by instructing them to 
rotate in place and determining on which side they detect the pillar.
  
- The yellow and grey robots can be identified by instructing them to
move down the hallway to their right and determining who encounters a 
wall first.

- The cyan, magenta, and blue robots can be identified by instructing
them to move forward and determining: a) how long it takes to encounter
a hallway intersection, and b) on which sides they they detect a wall.


Observation about Java Player/Stage Implementation
------------------------------------------------------------------------

The Java Player/Stage implementation is not as good as the C++ 
implementation in regards to making periodic position updates. It often
skips a 10th of a second. For example, if the robot is instructed to
rotate at 45 degrees per second, the Java implementation may report a
jump from 0 to 90 degrees after one call to readAll(). For this reason,
a distance-based movement algorithm is preferred over a time-based
algorithm. 

When one runs Localize.java he will notice that the blue or magenta 
robot will rotate and then may appear to stop for a moment before moving
forward. The robot has not actually stopped at this time, rather it is 
just adjusting its position in small increments to mitigate the 
effect of the Java implementation's poor positional updates. This 
problem may be resolved by utilizing threads, however it is probably a 
consequence of using an interpreted language and all of the additional 
overhead involved when compared with a non-interpreted language like 
C++.

